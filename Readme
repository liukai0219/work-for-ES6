学习教材
https://es6.ruanyifeng.com/

1.let和var的区别
 let是ES6新增的，用来声明变量。只在所在代码块生效。var声明的变量在代码块外面也能使用。
 let不允许重复声明，var允许。
 
 for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
 for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
 }
 // abc
 // abc
 // abc
 
2.常量定义
 const a = "a";
 const b = {}; //{}表示对象，[]表示数组
 const声明常量实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，
 const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，
 就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
 

3.变量的解构赋值
 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
 
 数组解构
 let [foo, [[bar], baz]] = [1, [[2], 3]];
 foo // 1
 bar // 2
 baz // 3
 只要等号两边模式一致，就可以给左边的变量赋予对应的值。
 如果解构不成功，变量的值就等于undefined。
 let [x, y, ...z] = ['a'];
 x // "a"
 y // undefined
 z // []
 注 : ...可以接收多个值，当作数组处理。
 
 默认值，当解构不成功时，赋值为默认值。
 let [x, y = 'b'] = ['a']; // x='a', y='b'
 
 对象解构
 let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
 foo // "aaa"
 bar // "bbb"
 对象的解构是需要变量名和属性名同名才能取到对应的值。
 没有取到则为undefined
 
 变量名和属性名不一致时，需要写成下面形式
 let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
 baz // "aaa"
 foo：baz中的foo只是用来匹配的，不会被赋值。
 
 对象解构可以方便的将对象的方法赋值给变量，
 let { log, sin, cos } = Math;
 
 在模块加载时，用来加载模块中的对应方法。
 import { connect } from 'react-redux';
 
 4.字符串
  把码点解析为字符：String.fromCodePoint(0x20BB7);
  
  字符串遍历for ...of
  for (let codePoint of 'foo') {
   console.log(codePoint)
  }
  // "f"
  // "o"
  // "o"
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 模块加载
 ES6 模块不是对象，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入。

 // ES6模块
 import { stat, exists, readFile } from 'fs';

 上面代码的实质是从`fs`模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载
 即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。
 当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。
 
 
 
 
 
 
 
 
 
 















