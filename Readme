学习教材
https://es6.ruanyifeng.com/

1.let和var的区别
 let是ES6新增的，用来声明变量。只在所在代码块生效。var声明的变量在代码块外面也能使用。
 let不允许重复声明，var允许。
 
 for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
 for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
 }
 // abc
 // abc
 // abc
 
2.常量定义
 const a = "a";
 const b = {}; //{}表示对象，[]表示数组
 const声明常量实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，
 const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，
 就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
 

3.变量的解构赋值
 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
 
 数组解构
 let [foo, [[bar], baz]] = [1, [[2], 3]];
 foo // 1
 bar // 2
 baz // 3
 只要等号两边模式一致，就可以给左边的变量赋予对应的值。
 如果解构不成功，变量的值就等于undefined。
 let [x, y, ...z] = ['a'];
 x // "a"
 y // undefined
 z // []
 注 : ...可以接收多个值，当作数组处理。
 
 默认值，当解构不成功时，赋值为默认值。
 let [x, y = 'b'] = ['a']; // x='a', y='b'
 
 对象解构
 let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
 foo // "aaa"
 bar // "bbb"
 对象的解构是需要变量名和属性名同名才能取到对应的值。
 没有取到则为undefined
 
 变量名和属性名不一致时，需要写成下面形式
 let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
 baz // "aaa"
 foo：baz中的foo只是用来匹配的，不会被赋值。
 
 对象解构可以方便的将对象的方法赋值给变量，
 let { log, sin, cos } = Math;
 
 在模块加载时，用来加载模块中的对应方法。
 import { connect } from 'react-redux';
 
 4.字符串
  把码点解析为字符：String.fromCodePoint(0x20BB7); ES6提供的方法。
  ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。
  
  字符串遍历for ...of
  for (let codePoint of 'foo') {
   console.log(codePoint)
  }
  // "f"
  // "o"
  // "o"
 
 字符串模板（使用反引号[`]）
 可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
 // 普通字符串
 `In JavaScript '\n' is a line-feed.`
 // 多行字符串
 console.log(`string text line 1
 string text line 2`);
 // 字符串中嵌入变量
 let name = "Bob", time = "today";
 `Hello ${name}, how are you ${time}?`
 

 新增方法
 JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。
 includes()：返回布尔值，表示是否找到了参数字符串。
 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
 repeat():方法返回一个新字符串，表示将原字符串重复n次。
  'hello'.repeat(2) // "hellohello"
 padStart(),padEnd()如果某个字符串不够指定长度，会在头部或尾部补全
  'x'.padStart(5, 'ab') // 'ababx'
  'x'.padEnd(5, 'ab') // 'xabab'
  trimStart(),trimEnd(),trim()删除开头/末尾/开头和末尾的空格(tab 键、换行符等不可见的空白符号也有效。)
  matchAll()方法返回一个正则表达式在当前字符串的所有匹配
  
  
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 模块加载
 ES6 模块不是对象，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入。

 // ES6模块
 import { stat, exists, readFile } from 'fs';

 上面代码的实质是从`fs`模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载
 即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。
 当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。
 
 
 
 
 
 
 
 
 
 















